<<<<<<< HEAD
---
title: 'DS105M: Women In Parliament - Data'
author: AS, NC, LM
output:
  ioslides_presentation: default
  slidy_presentation: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r packages, include=FALSE}
if(!require("pacman"))install.packages("pacman")

pacman::p_load("tidyverse", "reticulate", "here")

#use_python("C:/Users/lenna/anaconda3/bin/python")

#initialize_python()
#import(pandas)
```


```{r data, include=FALSE}
#source(here("scripts", "download-csv-html.R")) # once you have run the script once, you can comment out this line by typing "#" in front of it. Doing this will mean the data loads directly from your local data_raw folder rather than downloading every time.

#harvard <- read.csv(here("data_raw", "rawdata.csv"))

#source_python(here("scripts", "test.py"))
```

## Brief summary

Our project looks at the relative proportions that MPs speak in the Scottish Parliament.

## Organisation of the project

* Guiding principle: reproducibility

* Source code of everything we produce avaliable on GitHub
  * Is why we coded slides

* Any user able to download the repo and run
  * Programmatic data download and cleaning


## Main data collection and cleaning

## Expansion

We wanted to compare speech time in Parliament with tweet frequency for each MP.

Our process would have been:

* Scrape MP tweet_ids from Wiki-data. Wiki-IDs are included as document metadata so we could have written a program that finds the relevant tweet ID from each politician.

* Pull timelines for each politician

However, API licence doesn't allow this - is that true?

```{r}
#harvard_speeches_only <- subset(harvard, harvard$is_speech == 1)
#no_speeches <- nrow(harvard_speeches_only)
```

There were `r #nrow(subset(harvard, harvard$is_speech == 1))` speeches.

```{r}

```
=======
---
title: "DS105M: Women In Parliament - Data"
author: AS, NC, LM
date: November 26, 2021
output:
  slidy_presentation: default
  ioslides_presentation: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r packages, include=FALSE}
if(!require("pacman"))install.packages("pacman")

pacman::p_load("tidyverse", "reticulate", "here")

#use_python("C:/Users/lenna/anaconda3/bin/python")

#initialize_python()
#import(pandas)
```


```{r data, include=FALSE}
#source(here("scripts", "download-csv-html.R")) # once you have run the script once, you can comment out this line by typing "#" in front of it. Doing this will mean the data loads directly from your local data_raw folder rather than downloading every time. 

harvard <- read.csv(here("data_raw", "rawdata.csv"))

#source_python(here("scripts", "test.py"))
```

## Brief summary 

Our project looks at the relative proportions that MPs speak in the Scottish Parliament. 

## Organisation of the project

* Guiding principle: reproducibility 

* Source code of everything we produce avaliable on GitHub 
  * Is why we coded slides 
  
* Any user able to download the repo and run
  * Programmatic data download and cleaning 


## Main data collection and cleaning 

## Expansion 

We wanted to compare speech time in Parliament with tweet frequency for each MP. 

Our process would have been: 

* Scrape MP tweet_ids from Wiki-data. Wiki-IDs are included as document metadata so we could have written a program that finds the relevant tweet ID from each politician. 

* Pull timelines for each politician 

However, API licence doesn't allow this - is that true?


## Summary statistics


```{r}
speeches <- subset(harvard, harvard$is_speech == 1)
```

## Summary statistics on speeches 

Some key facts about the speeches:

* There were `r nrow(speeches)` speeches.
* `r nrow(subset(speeches, speeches$gender == "F"))` of the speeches were by women.
* `r (nrow(subset(speeches, speeches$gender == "F"))/ nrow(speeches))*100`% of the speeches in our sample were by women.

## Summary statistics on MSPs

```{r}
msps <- speeches %>% select(name, gender)
 
msps <- unique(msps)

msps <- drop_na(msps)
```


Some facts about the MSPs in our sample

* There were a total of `r nrow(msps)` in our sample

* `r nrow(subset(msps, msps$gender == "F"))` were women 

* Therefore, `r (nrow(subset(msps, msps$gender == "F"))/ nrow(msps))*100`% of the MSPs in out sample are women. 
## Our next steps


>>>>>>> 840ec07c2a89e96c1231e909690ecb66a5307ef1
